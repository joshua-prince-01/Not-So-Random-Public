/* 
  Sketch generated by the Arduino IoT Cloud Thing "Dual_UNO_MKR_Motor_Control_A"
  https://create.arduino.cc/cloud/things/26def446-42c3-490a-92b6-6b636fb41e79 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float motor_runout;
  float motor_speed;
  bool motor_direction;
  bool motor_enable;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/
#include "arduino_secrets.h"
#include "thingProperties.h"
#include <Wire.h>

// 2 will be the slave MKR 1010 Wifi's address
#define SLAVE_ADDR 0x08

// debug global variables
const uint32_t PERIOD = 500; // 2 Hz
const uint32_t START_PERIOD = 125; // 8 HZ
bool START_UP = true;

// speed multiplier
float speed_multiplier = 3.5;
void setup() {

  // Serial debugging
  Serial.begin(115200);
  delay(1500);
  
  // Use LED for debugging
  pinMode(LED_BUILTIN, OUTPUT);
  unsigned long current_time = 0;

  // Defined in thingProperties.h
  initProperties();

  // Join I2C as master
  Wire.begin();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  // Once connceted blink at 8 Hz
  startupLED();

  // Initial push so slave starts with sane defaults:
   sendMotorUpdate(motor_enable, motor_direction, motor_speed, motor_runout);
}

void loop() {
  ArduinoCloud.update();
  // Your code here 
  if(START_UP) {
    if (ArduinoCloud.connected()) {
      START_UP = false;
    } else {
      startupLED();
    }
    blinkLED();
  }
}

// ===== I2C Update ======
void sendMotorUpdate(bool en, bool dir, float speed, float motor_run) {
  // create byte buffer based on data we want to send
  
  // update speed based on multiplier
  speed = speed * speed_multiplier;

  // 2 flags + 2 floats = 10 bytes
  uint8_t buf[2 + sizeof(speed) + sizeof(motor_run)];
  
  // first byte is a enable flag
  buf[0] = en ? 1 : 0;
  
  // second byte is direction
  buf[1] = dir ? 1: 0;
  
  // remaining bytes are the speed and runtout floats
  memcpy(buf + 2, &speed, sizeof(speed));
  memcpy(buf + 2 + sizeof(speed), &motor_run, sizeof(motor_run));

  // debug print (optional)
  Serial.print("I2C ▶ ");
   for (size_t i = 0; i < sizeof(buf); i++) {
    if (buf[i] < 16) Serial.print('0');
    Serial.print(buf[i], HEX);
    Serial.print(' ');
  }
  Serial.println();
  blinkLED(); // blink onboard LED

  // send over I2C
  Wire.beginTransmission(SLAVE_ADDR);
  Wire.write(buf, sizeof(buf));
  Wire.endTransmission();
}

// Cloud Callbacks
void onMotorDirectionChange()  {sendMotorUpdate(motor_enable, motor_direction, motor_speed, motor_runout);}
void onMotorSpeedChange()  {sendMotorUpdate(motor_enable, motor_direction, motor_speed, motor_runout);}
void onMotorRunoutChange()  {sendMotorUpdate(motor_enable, motor_direction, motor_speed, motor_runout);}
void onMotorEnableChange()  {sendMotorUpdate(motor_enable, motor_direction, motor_speed, motor_runout);}
void onDeviceStatusChange() {}


void blinkLED() {
// Use the onboard LED to signal board status to user
  static uint32_t tPrev = 0;      // remember last toggle time
  static bool     ledOn = false;  // remember current state

  uint32_t now = millis();      // current time

    if (now - tPrev >= PERIOD) {    // check if it is time to toggle?
      tPrev = now;                  // restart interval
      ledOn = !ledOn;               // flip state
      digitalWrite(LED_BUILTIN, ledOn); // apply new state
    }
}

void startupLED() {
// While this won't trully "blink" it will flash the LED once to signal moving from Setup to Loop
  static uint32_t tPrev = 0;      // remember last toggle time
  static bool     ledOn = false;  // remember current state

  uint32_t now = millis();      // current time

    if (now - tPrev >= START_PERIOD) {    // check if it is time to toggle?
      tPrev = now;                  // restart interval
      ledOn = !ledOn;               // flip state
      digitalWrite(LED_BUILTIN, ledOn); // apply new state
    }
}